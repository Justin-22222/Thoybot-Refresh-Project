{"version":3,"sources":["../../src/core/dotenv.ts"],"names":["existsSync","readFileSync","readFile","path","IS_BUN","logger","parseEnvFile","envFileContent","lines","commentRegex","quotesRegex","escapedCharsRegex","currentLine","newEnvVars","i","delimiterIndex","key","value","loadEnv","options","mode","overwrite","filePath","varSubstitutionRegex","envClone","visited","_","varName","err"],"mappings":"AAAA,OAAS,cAAAA,EAAY,gBAAAC,MAAoB,UACzC,OAAS,YAAAC,MAAgB,mBACzB,OAAOC,MAAU,YACjB,OAAS,UAAAC,MAAc,gCACvB,OAAS,UAAAC,MAAc,cAEvB,SAASC,EAAaC,EAAmD,CACxE,MAAMC,EAAQD,EAAe,MAAM;AAAA,CAAI,EACjCE,EAAe,QACfC,EAAc,QACdC,EAAoB,SAE1B,IAAIC,EAAc,GAClB,MAAMC,EAAwC,CAAC,EAE/C,QAASC,EAAI,EAAGA,EAAIN,EAAM,OAAQM,IAAK,CAItC,GAHAF,GAAeJ,EAAMM,CAAC,EAGlBL,EAAa,KAAKG,CAAW,EAAG,CACnCA,EAAc,GACd,SAID,GAAIA,EAAY,SAAS,IAAI,EAAG,CAC/BA,EAAcA,EAAY,MAAM,EAAG,EAAE,EACrC,SAID,MAAMG,EAAiBH,EAAY,QAAQ,GAAG,EAC9C,GAAIG,IAAmB,GAAI,CAC1BH,EAAc,GACd,SAGD,MAAMI,EAAMJ,EAAY,OAAO,EAAGG,CAAc,EAAE,KAAK,EACvD,IAAIE,EAAQL,EAAY,OAAOG,EAAiB,CAAC,EAAE,KAAK,EAGpDL,EAAY,KAAKO,CAAK,IACzBA,EAAQA,EAAM,MAAM,EAAG,EAAE,EAAE,QAAQN,EAAmB,IAAI,GAG3DE,EAAWG,CAAG,EAAIC,EAClBL,EAAc,GAGf,OAAOC,CACR,CASA,eAAsBK,EAAQC,EAA0B,CAAC,EAAkB,CAE1E,GAAIf,EACH,OAID,KAAM,CAAE,KAAAgB,EAAM,UAAAC,CAAU,EAAIF,EAC5B,GAAI,CAAE,SAAAG,EAAWnB,EAAK,KAAK,QAAQ,IAAI,EAAG,MAAM,CAAE,EAAIgB,EAMtD,GAJIC,GAAQpB,EAAWsB,EAAW,IAAMF,CAAI,IAC3Cf,EAAO,MAAM,4BAA6Be,EAAM,IAAKE,EAAW,IAAMF,CAAI,EAC1EE,EAAWnB,EAAK,KAAK,QAAQ,IAAI,EAAG,QAAeiB,CAAI,GAEpD,CAACpB,EAAWsB,CAAQ,EAAG,CAC1BjB,EAAO,MAAM,0BAA0BiB,IAAW,EAClD,OAGD,MAAMf,EAAiBY,EAAQ,KAAOlB,EAAaqB,EAAU,OAAO,EAAI,MAAMpB,EAASoB,EAAU,OAAO,EAClGT,EAAaP,EAAaC,CAAc,EACxCgB,EAAuB,aAGvBC,EAAW,CAAE,GAAG,QAAQ,GAAI,EAElC,GAAI,CACH,UAAWR,KAAOH,EAAY,CAE7B,GAAI,CAACQ,GAAaL,KAAOQ,EACxB,SAGD,MAAMC,EAAU,IAAI,IACpB,IAAIR,EAAQJ,EAAWG,CAAG,EAE1B,KAAOO,EAAqB,KAAKN,CAAK,GACrCA,EAAQA,EAAM,QAAQM,EAAsB,CAACG,EAAGC,IAAY,CAC3D,GAAIF,EAAQ,IAAIE,CAAO,EACtB,MAAM,IAAI,MAAM,wDAAwDX,IAAM,EAE/E,OAAAS,EAAQ,IAAIE,CAAO,EACZH,EAASG,CAAO,GAAKd,EAAWc,CAAO,GAAK,EACpD,CAAC,EAGFH,EAASR,CAAG,EAAIC,EAGjB,OAAO,OAAO,QAAQ,IAAKO,CAAQ,CACpC,OAASI,EAAP,CACD,QAAQ,MAAM,6CAA8CA,CAAG,CAChE,CACD","sourcesContent":["import { existsSync, readFileSync } from 'node:fs'\nimport { readFile } from 'node:fs/promises'\nimport path from 'node:path'\nimport { IS_BUN } from '../cli/utils/runtime-utils.js'\nimport { logger } from './logger.js'\n\nfunction parseEnvFile(envFileContent: string): { [key: string]: string } {\n\tconst lines = envFileContent.split('\\n')\n\tconst commentRegex = /^\\s*#/\n\tconst quotesRegex = /^['\"]/\n\tconst escapedCharsRegex = /\\\\(.)/g\n\n\tlet currentLine = ''\n\tconst newEnvVars: { [key: string]: string } = {}\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tcurrentLine += lines[i]\n\n\t\t// Ignore comments\n\t\tif (commentRegex.test(currentLine)) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue\n\t\t}\n\n\t\t// Multiline support\n\t\tif (currentLine.endsWith('\\\\')) {\n\t\t\tcurrentLine = currentLine.slice(0, -1)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find first index of '=', and split key/value there\n\t\tconst delimiterIndex = currentLine.indexOf('=')\n\t\tif (delimiterIndex === -1) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue // Ignore lines that aren't key-value pairs\n\t\t}\n\n\t\tconst key = currentLine.substr(0, delimiterIndex).trim()\n\t\tlet value = currentLine.substr(delimiterIndex + 1).trim()\n\n\t\t// Remove surrounding quotes and unescape\n\t\tif (quotesRegex.test(value)) {\n\t\t\tvalue = value.slice(1, -1).replace(escapedCharsRegex, '$1')\n\t\t}\n\n\t\tnewEnvVars[key] = value\n\t\tcurrentLine = ''\n\t}\n\n\treturn newEnvVars\n}\n\ninterface LoadEnvOptions {\n\tfilePath?: string\n\tmode?: string\n\toverwrite?: boolean\n\tsync?: boolean\n}\n\nexport async function loadEnv(options: LoadEnvOptions = {}): Promise<void> {\n\t// No need to load .env file if using Bun (it's already loaded)\n\tif (IS_BUN) {\n\t\treturn\n\t}\n\n\t// Look for .env.{mode} file first, then fallback to standard .env\n\tconst { mode, overwrite } = options\n\tlet { filePath = path.join(process.cwd(), '.env') } = options\n\n\tif (mode && existsSync(filePath + '.' + mode)) {\n\t\tlogger.debug('Found .env file for mode:', mode, ':', filePath + '.' + mode)\n\t\tfilePath = path.join(process.cwd(), '.env' + '.' + mode)\n\t}\n\tif (!existsSync(filePath)) {\n\t\tlogger.debug(`No .env file found at \"${filePath}\"`)\n\t\treturn\n\t}\n\n\tconst envFileContent = options.sync ? readFileSync(filePath, 'utf-8') : await readFile(filePath, 'utf-8')\n\tconst newEnvVars = parseEnvFile(envFileContent)\n\tconst varSubstitutionRegex = /\\${(.+?)}/g\n\n\t// Create a clone of process.env to maintain a consistent state in case of an error\n\tconst envClone = { ...process.env }\n\n\ttry {\n\t\tfor (const key in newEnvVars) {\n\t\t\t// Don't overwrite existing values unless specified\n\t\t\tif (!overwrite && key in envClone) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst visited = new Set<string>()\n\t\t\tlet value = newEnvVars[key]\n\n\t\t\twhile (varSubstitutionRegex.test(value)) {\n\t\t\t\tvalue = value.replace(varSubstitutionRegex, (_, varName) => {\n\t\t\t\t\tif (visited.has(varName)) {\n\t\t\t\t\t\tthrow new Error(`Circular reference detected in environment variable \"${key}\"`)\n\t\t\t\t\t}\n\t\t\t\t\tvisited.add(varName)\n\t\t\t\t\treturn envClone[varName] || newEnvVars[varName] || ''\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tenvClone[key] = value\n\t\t}\n\n\t\tObject.assign(process.env, envClone)\n\t} catch (err) {\n\t\tconsole.error(`Error while loading environment variables:`, err)\n\t}\n}\n"]}
import { color } from './color.js';
import { registerProcessEvents } from './process.js';
import { Compiler } from './../cli/utils/compiler.js';
import { Client, Events, Collection } from 'discord.js';
import { loadConfig, getConfig } from './config.js';
import { discordLogger, FLASHCORE_KEYS } from './constants.js';
import { logger } from './logger.js';
import { env } from './env.js';
import { executeEventHandler, executeCommandHandler, executeAutocompleteHandler, executeContextHandler } from './handlers.js';
import { PackageDir, hasProperties } from '../cli/utils/utils.js';
import { prepareFlashcore, Flashcore } from './flashcore.js';
import { loadState } from './state.js';
import h from './portal.js';
import _ from 'node:path';
import { isMainThread, parentPort } from 'node:worker_threads';

const se={restart:J,start:F,stop:G};let i;const S=new h;let v;async function F(t){const{client:r,shard:s,stateLoad:c}=t??{};registerProcessEvents();const[o]=await Promise.all([loadConfig(),Compiler.useManifest()]);if(logger({drain:o?.logger?.drain,enabled:o?.logger?.enabled,level:o?.logger?.level}).debug("Starting Robo..."),s&&o.experimental?.disableBot!==!0){discordLogger.debug("Sharding is enabled. Delegating start to shard manager...");const{ShardingManager:e}=await import('discord.js'),a=typeof s=="string"?s:_.join(PackageDir,"dist","cli","shard.js"),m=typeof o.experimental?.shard=="object"?o.experimental.shard:{},f=new e(a,{...m,token:env("discord.token")});f.on("shardCreate",P=>discordLogger.debug("Launched shard",P.id));const C=await f.spawn();discordLogger.debug("Spawned",C.size,"shard(s)");return}if(await prepareFlashcore(),c)logger.debug("Waiting for state..."),await c;else {const e=Date.now(),a=await Flashcore.get(FLASHCORE_KEYS.state);a&&loadState(a),logger.debug(`State loaded in ${Date.now()-e}ms`);}const d=z();if(o.experimental?.disableBot!==!0?i=r??new Client(o.clientOptions):logger.debug("Bot is disabled, skipping client setup..."),await h.open(),await executeEventHandler(d,"_start",i),o.experimental?.disableBot!==!0){for(const e of S.events.keys()){const a=S.events.get(e).every(m=>m.auto);i.on(e,async(...m)=>{a||discordLogger.event(`Event received: ${color.bold(e)}`),discordLogger.trace("Event args:",m),executeEventHandler(d,e,...m);});}i.on(Events.InteractionCreate,async e=>{if(e.isChatInputCommand()){const a=x(e);discordLogger.event(`Received slash command interaction: ${color.bold("/"+a)}`),discordLogger.trace("Slash command interaction:",e.toJSON()),await executeCommandHandler(e,a);}else if(e.isAutocomplete()){const a=x(e);discordLogger.event(`Received autocomplete interaction for: ${color.bold(e.commandName)}`),discordLogger.trace("Autocomplete interaction:",e.toJSON()),await executeAutocompleteHandler(e,a);}else e.isContextMenuCommand()&&(discordLogger.event(`Received context menu interaction: ${color.bold(e.commandName)}`),discordLogger.trace("Context menu interaction:",e.toJSON()),await executeContextHandler(e,e.commandName));}),await i.login(env("discord.token"));}}async function G(t=0){try{await executeEventHandler(v,"_stop",i),i?.destroy(),logger.debug("Stopped Robo at "+new Date().toLocaleString());}finally{isMainThread||(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close()),process.exit(t);}}async function J(){try{await executeEventHandler(v,"_restart",i),i?.destroy(),logger.debug("Restarted Robo at "+new Date().toLocaleString());}finally{isMainThread?process.exit(0):(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close(),process.exit());}}function x(t){const r=[t.commandName];if(hasProperties(t.options,["getSubcommandGroup"]))try{r.push(t.options.getSubcommandGroup());}catch{}if(hasProperties(t.options,["getSubcommand"]))try{r.push(t.options.getSubcommand());}catch{}return r.filter(Boolean).join(" ")}function z(){const t=getConfig(),r=new Collection;if(!t.plugins)return r;for(const s of t.plugins)if(typeof s=="string")r.set(s,{name:s});else if(Array.isArray(s)){const[c,o,d]=s;r.set(c,{name:c,options:o,metaOptions:d});}return r}

export { se as Robo, i as client, S as portal };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=robo.js.map
{"version":3,"sources":["../../src/core/config.ts"],"names":["logger","fs","existsSync","path","pathToFileURL","Mode","_config","_configPaths","getConfig","getConfigPaths","loadConfig","file","configPath","loadConfigPath","config","readConfig","scanPlugins","plugin","pluginConfig","pluginPath","existingIndex","p","extensions","prefixes","prefix","pathBase","ext","fullPath","callback","pluginsPath","plugins","pluginData","scopedPlugins","scopedPlugin","scopedPath","parts","pluginName","mode","modeVariant","rawData","imported","e"],"mappings":"AACA,OAAS,UAAAA,MAAc,cACvB,OAAOC,GAAM,cAAAC,MAAkB,UAC/B,OAAOC,MAAU,YACjB,OAAS,iBAAAC,MAAqB,WAC9B,OAAS,QAAAC,MAAY,YAGrB,IAAIC,EAAkB,KACtB,MAAMC,EAA4B,IAAI,IAM/B,SAASC,GAA2B,CAC1C,OAAOF,CACR,CAKO,SAASG,GAA8B,CAC7C,OAAOF,CACR,CAEA,eAAsBG,EAAWC,EAAO,OAAyB,CAChE,MAAMC,EAAa,MAAMC,EAAeF,CAAI,EAC5C,IAAIG,EAEJ,OAAIF,GACHE,EAAS,MAAMC,EAAmBH,CAAU,EAC5CL,EAAa,IAAIK,CAAU,EAGvBA,EAAW,SAAST,EAAK,IAAM,SAAWA,EAAK,GAAG,IACrDH,EAAO,MAAM,8BAA8B,EAC3Cc,EAAO,QAAUA,EAAO,SAAW,CAAC,EAEpC,MAAME,EAAYJ,EAAY,CAACK,EAAQC,EAAcC,IAAe,CAEnE,MAAMC,EAAgBN,EAAO,SAAS,UAAWO,GAAMA,IAAMJ,GAAUI,EAAE,CAAC,IAAMJ,CAAM,EAClFG,IAAkB,IACrBN,EAAO,SAAS,OAAOM,EAAe,CAAC,EAGxCN,EAAO,SAAS,KAAK,CAACG,EAAQC,CAAY,CAAC,EAC3CX,EAAa,IAAIY,CAAU,CAC5B,CAAC,IAGFL,EAAS,CACR,cAAe,CACd,QAAS,CAAC,CACX,CACD,EAGDR,EAAUQ,EACVd,EAAO,MAAM,6BAA8Bc,CAAM,EAC1CA,CACR,CAoBA,eAAsBD,EAAeF,EAAO,OAAyB,CACpE,MAAMW,EAAa,CAAC,OAAQ,OAAQ,OAAO,EACrCC,EAAW,CAAC,SAAU,SAAS,EAErC,UAAWC,KAAUD,EAAU,CAC9B,MAAME,EAAWtB,EAAK,KAAK,QAAQ,IAAI,EAAGqB,CAAM,EAEhD,UAAWE,KAAOJ,EAAY,CAC7B,IAAIK,EAAWxB,EAAK,KAAKsB,EAAU,GAAGd,KAAQN,EAAK,IAAI,IAAIqB,GAAK,EAEhE,GAAI,CACH,GAAIzB,EAAG,WAAW0B,CAAQ,EAEzB,OAAA3B,EAAO,MAAM,8BAA+B2B,CAAQ,EAC7CA,CAET,MAAE,CAEF,CAEA,GAAI,CAEH,GADAA,EAAWxB,EAAK,KAAKsB,EAAU,GAAGd,IAAOe,GAAK,EAC1CzB,EAAG,WAAW0B,CAAQ,EAEzB,OAAA3B,EAAO,MAAM,8BAA+B2B,CAAQ,EAC7CA,CAET,MAAE,CAEF,GAKF,OAAO,IACR,CAOA,eAAeX,EACdJ,EACAgB,EACC,CAED,MAAMC,EAAc1B,EAAK,KAAKA,EAAK,QAAQS,CAAU,EAAG,SAAS,EAEjE,GAAI,CAACX,EAAG,WAAW4B,CAAW,EAC7B,OAID,MAAMC,EAAU7B,EAAG,YAAY4B,CAAW,EACpCE,EAAkE,CAAC,EAEzE,UAAWd,KAAUa,EAAS,CAC7B,MAAMX,EAAahB,EAAK,KAAK0B,EAAaZ,CAAM,EAGhD,GAAIhB,EAAG,SAASkB,CAAU,EAAE,YAAY,EAAG,CAC1C,MAAMa,EAAgB/B,EAAG,YAAYkB,CAAU,EAE/C,UAAWc,KAAgBD,EAAe,CAEzC,MAAME,EAAa/B,EAAK,KAAKgB,EAAYc,CAAY,EAE/CE,EADehC,EAAK,SAAS0B,EAAaK,CAAU,EAC/B,MAAM,GAAG,EAC9BE,EAAa,IAAMD,EAAM,CAAC,EAChC,IAAIE,EACAF,EAAM,OAAS,IAClBE,EAAOF,EAAM,CAAC,GAGfJ,EAAW,KAAK,CAAE,KAAAM,EAAM,KAAMD,EAAY,KAAMF,CAAW,CAAC,OAEvD,CAGN,MAAMC,EADehC,EAAK,SAAS0B,EAAaV,CAAU,EAC/B,MAAM,GAAG,EAC9BiB,EAAaD,EAAM,CAAC,EAC1B,IAAIE,EACAF,EAAM,OAAS,IAClBE,EAAOF,EAAM,CAAC,GAGfJ,EAAW,KAAK,CAAE,KAAAM,EAAM,KAAMD,EAAY,KAAMjB,CAAW,CAAC,GAK9D,MAAM,QAAQ,IACbY,EAAW,IAAI,MAAOd,GAAW,CAEhC,GAAI,CAACA,EAAO,KAAM,CACjB,MAAMqB,EAAcP,EAAW,KAAMV,GAAMA,EAAE,OAAShB,EAAK,IAAI,GAAKgB,EAAE,OAASJ,EAAO,IAAI,EAE1F,GAAIf,EAAWoC,GAAa,IAAI,EAC/B,OAKF,GAAIrB,EAAO,MAAQA,EAAO,OAASZ,EAAK,IAAI,EAC3C,OAGD,MAAMa,EAAe,MAAMH,EAAWE,EAAO,IAAI,EACjDW,EAASX,EAAO,KAAMC,EAAcD,EAAO,IAAI,CAChD,CAAC,CACF,CACD,CAEA,eAAeF,EAAwBH,EAAgC,CACtE,GAAI,CACH,GAAIA,EAAW,SAAS,OAAO,EAAG,CAEjC,MAAM2B,EAAUtC,EAAG,aAAaW,EAAY,MAAM,EAElD,OADqB,KAAK,MAAM2B,CAAO,GAChB,CAAC,MAClB,CAEN,MAAMC,EAAW,MAAM,OAAOpC,EAAcQ,CAAU,EAAE,SAAS,GAEjE,OADqB4B,EAAS,SAAWA,GAClB,CAAC,EAE1B,OAASC,EAAP,CACD,OAAAzC,EAAO,MAAM,qCAAsCyC,CAAC,EAC7C,CAAC,CACT,CACD","sourcesContent":["import { Config } from '../types/index.js'\nimport { logger } from './logger.js'\nimport fs, { existsSync } from 'node:fs'\nimport path from 'node:path'\nimport { pathToFileURL } from 'node:url'\nimport { Mode } from './mode.js'\n\n// Global config reference\nlet _config: Config = null\nconst _configPaths: Set<string> = new Set()\n\n/**\n * Returns the currently loaded configuration.\n * May return null if config has yet to load. Use {@link loadConfig} to load it first.\n */\nexport function getConfig(): Config | null {\n\treturn _config\n}\n\n/**\n * Returns the paths to all loaded configuration files.\n */\nexport function getConfigPaths(): Set<string> {\n\treturn _configPaths\n}\n\nexport async function loadConfig(file = 'robo'): Promise<Config> {\n\tconst configPath = await loadConfigPath(file)\n\tlet config: Config\n\n\tif (configPath) {\n\t\tconfig = await readConfig<Config>(configPath)\n\t\t_configPaths.add(configPath)\n\n\t\t// Load plugin files when using \"/config\" directory\n\t\tif (configPath.includes(path.sep + 'config' + path.sep)) {\n\t\t\tlogger.debug('Scanning for plugin files...')\n\t\t\tconfig.plugins = config.plugins ?? []\n\n\t\t\tawait scanPlugins(configPath, (plugin, pluginConfig, pluginPath) => {\n\t\t\t\t// Remove existing plugin config if it exists\n\t\t\t\tconst existingIndex = config.plugins?.findIndex((p) => p === plugin || p[0] === plugin)\n\t\t\t\tif (existingIndex !== -1) {\n\t\t\t\t\tconfig.plugins?.splice(existingIndex, 1)\n\t\t\t\t}\n\n\t\t\t\tconfig.plugins?.push([plugin, pluginConfig])\n\t\t\t\t_configPaths.add(pluginPath)\n\t\t\t})\n\t\t}\n\t} else {\n\t\tconfig = {\n\t\t\tclientOptions: {\n\t\t\t\tintents: []\n\t\t\t}\n\t\t}\n\t}\n\n\t_config = config\n\tlogger.debug(`Loaded configuration file:`, config)\n\treturn config\n}\n\n/**\n * Looks for the config file in the current project.\n * Will look for the following files in order:\n * - config/robo.mjs\n * - config/robo.cjs\n * - config/robo.json\n * - .config/robo.mjs\n * - .config/robo.cjs\n * - .config/robo.json\n *\n * If a mode is set, it will prioritize the mode-specific config file.\n * - config/robo.{mode}.mjs\n * - config/robo.{mode}.cjs\n * - config/robo.{mode}.json\n *\n * @param file The name of the config file to look for. Defaults to \"robo\".\n * @returns The path to the config file, or null if it could not be found.\n */\nexport async function loadConfigPath(file = 'robo'): Promise<string> {\n\tconst extensions = ['.mjs', '.cjs', '.json']\n\tconst prefixes = ['config', '.config']\n\n\tfor (const prefix of prefixes) {\n\t\tconst pathBase = path.join(process.cwd(), prefix)\n\n\t\tfor (const ext of extensions) {\n\t\t\tlet fullPath = path.join(pathBase, `${file}.${Mode.get()}${ext}`)\n\n\t\t\ttry {\n\t\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\t\t// Convert to file URL to allow for dynamic import()\n\t\t\t\t\tlogger.debug(`Found configuration file at`, fullPath)\n\t\t\t\t\treturn fullPath\n\t\t\t\t}\n\t\t\t} catch (ignored) {\n\t\t\t\t// empty\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfullPath = path.join(pathBase, `${file}${ext}`)\n\t\t\t\tif (fs.existsSync(fullPath)) {\n\t\t\t\t\t// Convert to file URL to allow for dynamic import()\n\t\t\t\t\tlogger.debug(`Found configuration file at`, fullPath)\n\t\t\t\t\treturn fullPath\n\t\t\t\t}\n\t\t\t} catch (ignored) {\n\t\t\t\t// empty\n\t\t\t}\n\t\t}\n\t}\n\n\t// If no config file was found, return null\n\treturn null\n}\n\n/**\n * Scans the /plugins config subdirectory for plugins.\n *\n * @param callback A callback function to be called for each plugin found. The plugin name will be passed as the first argument, including the scoped organization if applicable. Second parameter is the plugin config object.\n */\nasync function scanPlugins(\n\tconfigPath: string,\n\tcallback: (plugin: string, pluginConfig: unknown, pluginPath: string) => void\n) {\n\t// Look for plugins in the same directory as the config file\n\tconst pluginsPath = path.join(path.dirname(configPath), 'plugins')\n\n\tif (!fs.existsSync(pluginsPath)) {\n\t\treturn\n\t}\n\n\t// For each file in the plugins directory, import it and add it to the config\n\tconst plugins = fs.readdirSync(pluginsPath)\n\tconst pluginData: Array<{ mode: string; name: string; path: string }> = []\n\n\tfor (const plugin of plugins) {\n\t\tconst pluginPath = path.join(pluginsPath, plugin)\n\n\t\t// Load subdirectories as scoped plugins\n\t\tif (fs.statSync(pluginPath).isDirectory()) {\n\t\t\tconst scopedPlugins = fs.readdirSync(pluginPath)\n\n\t\t\tfor (const scopedPlugin of scopedPlugins) {\n\t\t\t\t// Compute the file name, keeping the base path in mind for scoped config files\n\t\t\t\tconst scopedPath = path.join(pluginPath, scopedPlugin)\n\t\t\t\tconst resolvedPath = path.relative(pluginsPath, scopedPath)\n\t\t\t\tconst parts = resolvedPath.split('.')\n\t\t\t\tconst pluginName = '@' + parts[0]\n\t\t\t\tlet mode = undefined\n\t\t\t\tif (parts.length > 2) {\n\t\t\t\t\tmode = parts[1]\n\t\t\t\t}\n\n\t\t\t\tpluginData.push({ mode, name: pluginName, path: scopedPath })\n\t\t\t}\n\t\t} else {\n\t\t\t// Compute the file name, keeping the base path in mind for scoped config files\n\t\t\tconst resolvedPath = path.relative(pluginsPath, pluginPath)\n\t\t\tconst parts = resolvedPath.split('.')\n\t\t\tconst pluginName = parts[0]\n\t\t\tlet mode = undefined\n\t\t\tif (parts.length > 2) {\n\t\t\t\tmode = parts[1]\n\t\t\t}\n\n\t\t\tpluginData.push({ mode, name: pluginName, path: pluginPath })\n\t\t}\n\t}\n\n\t// Load all plugins in parallel\n\tawait Promise.all(\n\t\tpluginData.map(async (plugin) => {\n\t\t\t// Skip plugins without mode unless mode file is not found\n\t\t\tif (!plugin.mode) {\n\t\t\t\tconst modeVariant = pluginData.find((p) => p.mode === Mode.get() && p.name === plugin.name)\n\n\t\t\t\tif (existsSync(modeVariant?.path)) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Skip if this plugin's mode is not the current mode\n\t\t\tif (plugin.mode && plugin.mode !== Mode.get()) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst pluginConfig = await readConfig(plugin.path)\n\t\t\tcallback(plugin.name, pluginConfig, plugin.path)\n\t\t})\n\t)\n}\n\nasync function readConfig<T = unknown>(configPath: string): Promise<T> {\n\ttry {\n\t\tif (configPath.endsWith('.json')) {\n\t\t\t// If the file is a JSON file, handle it differently\n\t\t\tconst rawData = fs.readFileSync(configPath, 'utf8')\n\t\t\tconst pluginConfig = JSON.parse(rawData)\n\t\t\treturn pluginConfig ?? {}\n\t\t} else {\n\t\t\t// Convert to file URL to allow for a seamless dynamic import()\n\t\t\tconst imported = await import(pathToFileURL(configPath).toString())\n\t\t\tconst pluginConfig = imported.default ?? imported\n\t\t\treturn pluginConfig ?? {}\n\t\t}\n\t} catch (e) {\n\t\tlogger.error('Failed to load configuration file:', e)\n\t\treturn {} as T\n\t}\n}\n"]}